/**
 * File: utilities.h
 * License: Part of the CUAS-MPI project. Licensed under BSD 3 clause license. See LICENSE.txt file at
 * https://github.com/tudasc/CUAS-MPI/LICENSE.txt
 */

#ifndef CUAS_UTILITIES_H
#define CUAS_UTILITIES_H

#include "petsc.h"

#include <cxxabi.h>
#include <iomanip>
#include <sstream>
#include <string>
#include <vector>

namespace CUAS {

/**
 * see https://stackoverflow.com/questions/2342162/stdstring-formatting-like-sprintf
 */
std::string vformat(const char *format, ...);

/**
 * Provide string containing CUAS version number
 */
std::string version();

/**
 * Checks if a vector is strictly increasing.
 */
template <typename T>
bool isIncreasing(const std::vector<T> v) {
  for (typename std::vector<T>::size_type i = 0; i != v.size() - 1; ++i) {
    if (v[i] >= v[i + 1]) {
      return false;
    }
  }
  return true;
}

/**
 * string split
 * @param s input string to split
 * @param delim delimiter
 * @return std::vector which contains the individual strings
 */
inline std::vector<std::string> split(std::string const &s, char delim) {
  // FIXME modern c++20 way of split:
  // for (auto &&part : std::views::split(input, ','))
  std::vector<std::string> result;
  std::stringstream ss(s);
  std::string item;

  while (getline(ss, item, delim)) {
    result.push_back(item);
  }

  return result;
}

/**
 * demangle mangled function name e.g. generated by typeid(object).name()
 * @param mangled input string to demangle
 * @return std::string which contains the demangled name
 */
inline std::string demangle(char const *mangled) {
  int status;
  char *demangled = abi::__cxa_demangle(mangled, nullptr, nullptr, &status);

  std::string result = (status == 0) ? demangled : mangled;

  free(demangled);

  return result;
}

/**
 * get the demangled type of variable
 * @param var
 * @return std::string which contains the demangled name
 */
template <typename T>
std::string getDemangledTypeName(T &var) {
  return demangle(typeid(var).name());
}

/**
 * formats a variable as string
 * @param val
 * @return std::string representation of val
 */
template <typename T>
std::string toString(T val) {
  return std::to_string(val);
}

template <>
inline std::string toString<bool>(bool val) {
  return val ? "true" : "false";
}

template <>
inline std::string toString<std::string>(std::string val) {
  return val;
}

template <>
inline std::string toString<PetscScalar>(PetscScalar val) {
  std::ostringstream out;
  out << std::fixed << std::setprecision(15) << val;
  auto str = out.str();

  // remove superfluous zeros
  size_t pos = str.find_last_not_of('0');
  if (pos != std::string::npos && str[pos] == '.') {
    pos++;
  }
  str.erase(pos + 1, std::string::npos);

  return str;
}

}  // namespace CUAS

#endif
