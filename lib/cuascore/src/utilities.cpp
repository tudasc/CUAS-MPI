/**
 * File: utilities.cpp
 * License: Part of the CUAS-MPI project. Licensed under BSD 3 clause license. See LICENSE.txt file at
 * https://github.com/tudasc/CUAS-MPI/LICENSE.txt
 */

#include "utilities.h"

#include <petsc.h>            // PetscGetVersion
#include <petscconfiginfo.h>  // petscconfigureoptions

#include <netcdf.h>  // nc_inq_libvers

#include <cstdarg>
#include <vector>

namespace CUAS {

static const int TEMPORARY_STRING_LENGTH = 32768;

// These variables are autogenerated and compiled
// into the library by the gitversion.cmake script
extern "C" {
extern const char *GIT_REV;
extern const char *GIT_TAG;
extern const char *GIT_BRANCH;
}

inline std::string getCompilerInformation() {
  std::string cxx =
#ifdef __clang__
      "clang++";
#elif __GNUG__
      "g++";
#else
      "undefined";
#endif
  std::string cxx_ver =
#ifdef __clang__
      __clang_version__;
#elif __GNUG__
      __VERSION__;
#else
      "";
#endif

  return CUAS::vformat("Compiler: %s %s", cxx.c_str(), cxx_ver.c_str());
}

inline std::string getMPIInformation() {
  char buffer[TEMPORARY_STRING_LENGTH];
  // Assume that other MPI libraries implement this part of the MPI-3 standard...
  int string_length = TEMPORARY_STRING_LENGTH;
  MPI_Get_library_version(buffer, &string_length);

  return buffer;
}

inline std::string getPETScInformation() {
  char buffer[TEMPORARY_STRING_LENGTH];
  PetscGetVersion(buffer, TEMPORARY_STRING_LENGTH);

  return buffer;
}

inline std::string getPETScConfiguration() { return CUAS::vformat("PETSc configure: %s", petscconfigureoptions); }

inline std::string getNetCDFInformation() { return CUAS::vformat("NetCDF %s.", nc_inq_libvers()); }

std::string version() {
  char buffer[TEMPORARY_STRING_LENGTH];
  std::string result;

  result += CUAS::vformat("CUAS-MPI (branch: %s, tag: %s, commit: %s)", GIT_BRANCH, GIT_TAG, GIT_REV);
  result += "\n";
  result += getCompilerInformation();
  result += "\n";
  result += getMPIInformation();
  result += "\n";
  result += getPETScInformation();
  result += "\n";
  result += getPETScConfiguration();
  result += "\n";
  result += getNetCDFInformation();
  result += "\n";

  // CMAKE version needed? YF: guess not

  return result;
}

// requires at least C++11
std::string vformat(const char *const zcFormat, ...) {
  // initialize use of the variable argument array
  va_list vaArgs;
  va_start(vaArgs, zcFormat);

  // reliably acquire the size
  // from a copy of the variable argument array
  // and a functionally reliable call to mock the formatting
  va_list vaArgsCopy;
  va_copy(vaArgsCopy, vaArgs);
  const int iLen = std::vsnprintf(NULL, 0, zcFormat, vaArgsCopy);
  va_end(vaArgsCopy);

  // return a formatted string without risking memory mismanagement
  // and without assuming any compiler or platform specific behavior
  std::vector<char> zc(iLen + 1);
  std::vsnprintf(zc.data(), zc.size(), zcFormat, vaArgs);
  va_end(vaArgs);

  return std::string(zc.data(), iLen);
}

}  // namespace CUAS
